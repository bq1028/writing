<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width,initial-scale=1'>
    <style>*{box-sizing:border-box}body{margin:0;font-family:system-ui,sans-serif}</style>
    <title data-head="true">Defining Component APIs in React</title><meta name="description" content="The personal blog of Brent Jackson" data-head="true"/><meta name="author" content="Brent Jackson" data-head="true"/><meta name="twitter:card" content="summary" data-head="true"/><meta name="twitter:site" content="@jxnblk" data-head="true"/><meta name="twitter:title" content="Defining Component APIs in React" data-head="true"/><meta name="twitter:image" content="https://jxnblk.com/avatar.png" data-head="true"/><style data-styled-components="dUiVDW dAnclP ffIkcW iHZvIS fsERgr eSJKuO heJdfs ihezuW dprmrz kgOQiB jWPlsU iFQYCJ dTSnFq iQjkbY kLDilu kjJiZl gReYnD hKiLMS">
/* sc-component-id: sc-bdVaJa */
.sc-bdVaJa {} .ffIkcW{box-sizing:border-box;margin-left:auto;margin-right:auto;padding-bottom:128px;padding-left:16px;padding-right:16px;}.iHZvIS{box-sizing:border-box;}.fsERgr{line-height:1.625;box-sizing:border-box;margin-right:0px;-webkit-flex:none;-ms-flex:none;flex:none;} @media screen and (min-width:32em){.fsERgr{margin-right:0px;}} @media screen and (min-width:48em){.fsERgr{margin-right:256px;}}.eSJKuO{box-sizing:border-box;margin-top:128px;}
/* sc-component-id: sc-bwzfXH */
.sc-bwzfXH {} .hKiLMS{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}
/* sc-component-id: sc-bxivhb */
.sc-bxivhb {} .dUiVDW{font-family:system-ui,sans-serif;} .dUiVDW *{box-sizing:border-box;}
/* sc-component-id: sc-htoDjs */
.sc-htoDjs {} .dTSnFq{color:#0067ee;}
/* sc-component-id: sc-iwsKbI */
.sc-iwsKbI {} .heJdfs{color:inherit;display:block;-webkit-text-decoration:none;text-decoration:none;}
/* sc-component-id: sc-gqjmRU */
.sc-gqjmRU {} .jWPlsU{margin:0px;margin-bottom:32px;margin-top:16px;line-height:1.625;} ul .jWPlsU{margin-top:0;margin-bottom:0;}.iFQYCJ{margin:0px;margin-bottom:32px;margin-top:32px;padding-left:16px;font-size:20px;font-weight:700;}
/* sc-component-id: sc-VigVT */
.sc-VigVT {} .ihezuW{font-size:32px;font-weight:700;line-height:1.25;margin:0px;margin-bottom:64px;margin-top:64px;}.dprmrz{font-size:32px;font-weight:700;line-height:1.25;margin:0px;margin-bottom:16px;margin-top:32px;} @media screen and (min-width:32em){.dprmrz{font-size:48px;}}.kgOQiB{font-size:24px;font-weight:700;line-height:1.25;margin:0px;margin-bottom:16px;margin-top:32px;} @media screen and (min-width:32em){.kgOQiB{font-size:32px;}}
/* sc-component-id: sc-chPdSV */
.sc-chPdSV {} .gReYnD{font-size:20px;margin:0px;margin-bottom:32px;margin-top:32px;padding-left:16px;}
/* sc-component-id: sc-kGXeez */
.sc-kGXeez {} .kLDilu{font-size:14px;font-family:"SF Mono","Roboto Mono",Menlo,monospace;margin:0px;margin-bottom:32px;margin-top:32px;padding:16px;overflow:auto;background-color:#eee;}.kjJiZl{font-size:14px;font-family:"SF Mono","Roboto Mono",Menlo,monospace;margin:0px;margin-top:32px;overflow:auto;}
/* sc-component-id: sc-kpOJdX */
.sc-kpOJdX {} .iQjkbY{font-size:inherit;font-family:"SF Mono","Roboto Mono",Menlo,monospace;}
/* sc-component-id: sc-jAaTju */
.sc-jAaTju {} .dAnclP{margin-left:auto;margin-right:auto;padding-bottom:128px;padding-left:16px;padding-right:16px;max-width:1024px;}</style>
  </head>
  <body>
    <div id=root><div class="sc-bxivhb dUiVDW"><div class="sc-jAaTju dAnclP sc-bdVaJa ffIkcW sc-bdVaJa iHZvIS"><header><a class="sc-iwsKbI heJdfs" href="/writing/"><h1 class="sc-VigVT ihezuW" href="/">Jxnblk Writing</h1></a></header><main class="sc-bdVaJa fsERgr"><div><h1 class="sc-VigVT dprmrz" id="defining-component-apis-in-react"><a class="sc-iwsKbI heJdfs" href="#defining-component-apis-in-react">Defining Component APIs in React</a></h1><p class="sc-gqjmRU jWPlsU">Over the years, I’ve noticed patterns in how I tend to approach component APIs and building out applications and libraries.
The following is a collection of thoughts, opinions, and advice for defining component APIs that are meant to be more flexible, composable, and easier to understand.
None of these are hard-and-fast rules, but they’ve helped guide the way I think about organizing and creating components.</p><h2 class="sc-VigVT kgOQiB" id="aim-for-a-small-api-surface-area"><a class="sc-iwsKbI heJdfs" href="#aim-for-a-small-api-surface-area">Aim for a small API surface area</a></h2><p class="sc-gqjmRU jWPlsU">Just as the React library itself aims for a <a class="sc-htoDjs dTSnFq" href="https://www.youtube.com/watch?v=4anAwXYqLG8">Minimal API Surface Area</a>,
I recommend adopting a similar mindset when it comes to defining component APIs.
The fewer new things you need to learn, the easier it is for others to know how to use the components
that you create, making them more reusable.
If someone doesn’t understand your component API, the chance that they’ll duplicate your work increases.
This idea is at the core of how I approach creating components, and I find it helpful to keep in mind as I work.</p><h2 class="sc-VigVT kgOQiB" id="make-things-easy-to-find"><a class="sc-iwsKbI heJdfs" href="#make-things-easy-to-find">Make things easy to find</a></h2><p class="sc-gqjmRU jWPlsU">Start with a flat directory structure and don’t prematurely organize your code base.
Humans love to organize things, but we’re also really terrible at it.
Naming things is hard enough, and by creating a directory structure around your component library,
you might end up doing more work that makes it more difficult for others to find the things you’ve done.</p><p class="sc-gqjmRU jWPlsU">A single directory of components can get quite large before it becomes difficult for people to manage.
And if all the components are in a single folder,
you’ll get alphabetical ordering for free in most file-system tools,
which can help provide a more complete picture of the code base for others.</p><h2 class="sc-VigVT kgOQiB" id="avoid-renderthing-methods"><a class="sc-iwsKbI heJdfs" href="#avoid-renderthing-methods">Avoid renderThing methods</a></h2><p class="sc-gqjmRU jWPlsU">If you’ve defined a custom method in your component that starts with the word <code class="sc-kpOJdX iQjkbY">render</code>,
chances are that should be its own component.
As <a class="sc-htoDjs dTSnFq" href="https://mobile.twitter.com/chrisbiscardi/status/1004559213320814592">Chris Biscardi</a> puts it, <strong>“<!-- -->[It]<!-- --> effectively means there’s enough complexity to be worth breaking down”</strong>.
React’s smart about when to render or not render a component,
so by splitting these out into their own components, you can help React do its job better.</p><pre class="sc-kGXeez kLDilu">// Instead of this
class Items extends React.Component {
  renderItems ({ items }) {
    return items.map(item =&gt; (
      &lt;li key={item.id}&gt;
        {renderItem(item)}
      &lt;/li&gt;
    ))
  }

  renderItem (item) {
    return (
      &lt;div&gt;
        {item.name}
      &lt;/div&gt;
    )
  }

  render () {
    return (
      &lt;ul&gt;
        {renderItems(this.props)
      &lt;/ul&gt;
    )
  }
}
</pre><pre class="sc-kGXeez kLDilu">// Do this
const ItemList = ({ items }) =&gt;
  &lt;ul&gt;
    {items.map(item =&gt; (
      &lt;li key={item.id}&gt;
        &lt;Item {...item} /&gt;
      &lt;/li&gt;
    )}
  &lt;/ul&gt;

const Item = ({ name }) =&gt;
  &lt;div&gt;{item.name}&lt;/div&gt;

class Items extends React.Component {
  render () {
    const { items } = this.props
    return &lt;ItemList items={items} /&gt;
  }
}
</pre><h2 class="sc-VigVT kgOQiB" id="split-components-at-data-boundaries"><a class="sc-iwsKbI heJdfs" href="#split-components-at-data-boundaries">Split components at data boundaries</a></h2><p class="sc-gqjmRU jWPlsU">Often, components should be defined by the shape of your data.</p><blockquote class="sc-chPdSV gReYnD sc-gqjmRU iFQYCJ" font-weight="bold"><p class="sc-gqjmRU jWPlsU">Since you’re often displaying a JSON data model to a user, you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely.</p></blockquote><p class="sc-gqjmRU jWPlsU">– <a class="sc-htoDjs dTSnFq" href="https://facebook.github.io/react/docs/thinking-in-react.html">Thinking in React</a></p><p class="sc-gqjmRU jWPlsU">I often see people new to React attempt to replicate what I call &quot;<a class="sc-htoDjs dTSnFq" href="https://getbootstrap.com">Bootstrap</a>&quot; components,
that is UI components that have a visual boundary that’s not directly tied to any data structure.
React and BEM-like CSS-based components have different concerns.
Instead of creating a generic Card component that displays an image, heading, and link,
and that would require a custom props API, build components for the data that you’re displaying.
Maybe the generic Card component should be a ProductCard component that can accept the <code class="sc-kpOJdX iQjkbY">product</code> object from your database.</p><pre class="sc-kGXeez kLDilu">// Instead of this
&lt;Card
  image={product.thumbnail}
  title={product.name}
  text={product.description}
  link={product.permalink}
/&gt;

// Do this
&lt;ProductCard {...product} /&gt;
</pre><p class="sc-gqjmRU jWPlsU">Chances are, the specific styling that you need for the ProductCard isn’t all that reusable,
and you’ll likely only have this defined in one place in your code base.
You can follow the <a class="sc-htoDjs dTSnFq" href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">Rule of Three</a> in situations like this.
If you&#x27;ve duplicated the exact Card component structure three times in your code base,
then it’s probably worth abstracting it out into its own component.</p><h2 class="sc-VigVT kgOQiB" id="avoid-apropcalypse"><a class="sc-iwsKbI heJdfs" href="#avoid-apropcalypse">Avoid Apropcalypse</a></h2><p class="sc-gqjmRU jWPlsU">As <a class="sc-htoDjs dTSnFq" href="https://twitter.com/gurlcode">Jenn Creighton</a> calls it, avoid <a class="sc-htoDjs dTSnFq" href="https://speakerdeck.com/jenncreighton/flexible-architecture-for-react-components?slide=10">Apropcalypse</a>.
Don’t be afraid to create a new component rather than adding abritrary props and additional logic to a component.
For example, a Button component might accept props for different colors, sizes, and shapes,
but there’s not always a need to have every combination of those props available.</p><pre class="sc-kGXeez kLDilu">// Instead of this
&lt;Button
  variant=&#x27;secondary&#x27;
  size=&#x27;large&#x27;
  outline
  label=&#x27;Buy Now&#x27;
  icon=&#x27;shoppingBag&#x27;
  onClick={handleClick}
/&gt;

// Do this
&lt;SecondaryButton
  size=&#x27;large&#x27;
  onClick={handleClick}&gt;
  &lt;Icon name=&#x27;shoppingBag&#x27; /&gt;
  Buy Now
&lt;/SecondaryButton&gt;
</pre><p class="sc-gqjmRU jWPlsU">Your needs may vary, but reducing the number of custom props that any component requires is generally helpful,
and reducing the amount of logic in the render function can make the code base simpler and better-suited for code splitting.</p><h2 class="sc-VigVT kgOQiB" id="use-composition"><a class="sc-iwsKbI heJdfs" href="#use-composition">Use composition</a></h2><p class="sc-gqjmRU jWPlsU">Don’t reinvent <code class="sc-kpOJdX iQjkbY">props.children</code>.
If you’ve defined props that take arbitrary strings of text that aren’t based on a data structure,
it’s probably better to use composition.</p><pre class="sc-kGXeez kLDilu">// Instead of this
&lt;Header
  title=&#x27;Hello&#x27;
  subhead=&#x27;This is a header&#x27;
  text=&#x27;And it has arbitrary props&#x27;
/&gt;

// Do this
&lt;Header&gt;
  &lt;Heading&gt;Hello&lt;/Heading&gt;
  &lt;Subhead&gt;This is a header&lt;/Subhead&gt;
  &lt;Text&gt;And it uses composition&lt;/Text&gt;
&lt;/Header&gt;
</pre><p class="sc-gqjmRU jWPlsU">If you know React, you’ll already know the API for the composed version, and it shouldn’t require as much documentation as the former.
You might wrap the composed version into another component that <strong>is</strong> tied to a piece of data in your application,
but you’ll probably only need that component structure defined once in your code base.</p><pre class="sc-kGXeez kLDilu">// This makes sense as a component since it’s based on data
const PageHeader = ({
  title,
  description
}) =&gt;
  &lt;Header&gt;
    &lt;Heading&gt;{title}&lt;/Heading&gt;
    &lt;Text&gt;{description}&lt;/Text&gt;
  &lt;/Header&gt;

// And ideally can be used like this
&lt;PageHeader {...page} /&gt;
</pre><h2 class="sc-VigVT kgOQiB" id="avoid-boolean-props-for-enums"><a class="sc-iwsKbI heJdfs" href="#avoid-boolean-props-for-enums">Avoid boolean props for enums</a></h2><p class="sc-gqjmRU jWPlsU">It might be tempting to use <a class="sc-htoDjs dTSnFq" href="https://mobile.twitter.com/satya164/status/1015206655997472768">boolean props</a> as a convenient way to switch between variants of a component,
but it can sometimes create a confusing API.</p><p class="sc-gqjmRU jWPlsU">Take the following example:</p><pre class="sc-kGXeez kLDilu">&lt;Button primary /&gt;
&lt;Button secondary /&gt;
</pre><p class="sc-gqjmRU jWPlsU">What happens in the following case?</p><pre class="sc-kGXeez kLDilu">&lt;Button primary secondary /&gt;
</pre><p class="sc-gqjmRU jWPlsU">It’s impossible to know without diving into the code base or documentation.
Instead, try the following:</p><pre class="sc-kGXeez kLDilu">&lt;Button variant=&#x27;primary&#x27; /&gt;
</pre><p class="sc-gqjmRU jWPlsU">It’s a little more typing but arguably much more readable.</p><h2 class="sc-VigVT kgOQiB" id="keep-props-apis-parallel"><a class="sc-iwsKbI heJdfs" href="#keep-props-apis-parallel">Keep props APIs parallel</a></h2><p class="sc-gqjmRU jWPlsU">Whenever possible, resuse props from other components. For example, if you’re creating a date picker, use the same props that the native <code class="sc-kpOJdX iQjkbY">&lt;input type=&#x27;date&#x27; /&gt;</code> expects.
It’ll be easier to guess how it works and also easier to remember.</p><pre class="sc-kGXeez kLDilu">// Instead of this
&lt;DatePicker
  date={date}
  onSelect={handleDateChange}
/&gt;

// Do this
&lt;DatePicker
  value={date}
  onChange={handleDateChange}
/&gt;
</pre><p class="sc-gqjmRU jWPlsU">The <a class="sc-htoDjs dTSnFq" href="https://jxnblk.com/styled-system">Styled System</a> library encourages using a parallel style props API across multiple components.
For example, the <code class="sc-kpOJdX iQjkbY">color</code> prop works the same for all components included in <a class="sc-htoDjs dTSnFq" href="https://jxnblk.com/rebass">Rebass</a>,
which ends up having a sort of <strong>learn once, use anywhere</strong> effect.</p><pre class="sc-kGXeez kLDilu">// example from Rebass
&lt;Box color=&#x27;tomato&#x27; /&gt;
&lt;Heading color=&#x27;tomato&#x27; /&gt;
</pre><h2 class="sc-VigVT kgOQiB" id="ask-your-teammates"><a class="sc-iwsKbI heJdfs" href="#ask-your-teammates">Ask your teammates</a></h2><p class="sc-gqjmRU jWPlsU">These are just some of my own thoughts on how to define component APIs, and they might not suite your needs.
The best advice I can give is to talk to your teammates, create RFCs and PRs,
and try <a class="sc-htoDjs dTSnFq" href="https://ponyfoo.com/articles/readme-driven-development">Readme Driven Development</a>.
Writing React components is easy.
Creating a library of components that works well for your team is worth the time and effort to get right.</p></div><pre class="sc-kGXeez kjJiZl">Sun Jul 08 2018</pre></main><footer><div class="sc-bwzfXH hKiLMS sc-bdVaJa eSJKuO sc-bdVaJa eSJKuO"><a class="sc-iwsKbI heJdfs" href="https://jxnblk.com">Made by Jxnblk</a></div></footer></div><script>(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,"script","//www.google-analytics.com/analytics.js","ga"); ga("create", "UA-4603832-6", "auto"); ga("send", "pageview");</script></div></div>
    
  </body>
</html>